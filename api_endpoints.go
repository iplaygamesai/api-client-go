/*
Game Aggregator API Documentation

Universal API for casino operators to access games from multiple providers through a single integration.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package iplaygamesapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// EndpointsAPIService EndpointsAPI service
type EndpointsAPIService service

type ApiAddAContributionToAJackpotPoolRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	addAContributionToAJackpotPoolRequest *AddAContributionToAJackpotPoolRequest
}

func (r ApiAddAContributionToAJackpotPoolRequest) AddAContributionToAJackpotPoolRequest(addAContributionToAJackpotPoolRequest AddAContributionToAJackpotPoolRequest) ApiAddAContributionToAJackpotPoolRequest {
	r.addAContributionToAJackpotPoolRequest = &addAContributionToAJackpotPoolRequest
	return r
}

func (r ApiAddAContributionToAJackpotPoolRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddAContributionToAJackpotPoolExecute(r)
}

/*
AddAContributionToAJackpotPool Add a contribution to a jackpot pool



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddAContributionToAJackpotPoolRequest
*/
func (a *EndpointsAPIService) AddAContributionToAJackpotPool(ctx context.Context) ApiAddAContributionToAJackpotPoolRequest {
	return ApiAddAContributionToAJackpotPoolRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) AddAContributionToAJackpotPoolExecute(r ApiAddAContributionToAJackpotPoolRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.AddAContributionToAJackpotPool")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/jackpot/contribute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addAContributionToAJackpotPoolRequest == nil {
		return nil, reportError("addAContributionToAJackpotPoolRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addAContributionToAJackpotPoolRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAddGamesToAJackpotPoolTypeRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	addGamesToAJackpotPoolTypeRequest *AddGamesToAJackpotPoolTypeRequest
}

func (r ApiAddGamesToAJackpotPoolTypeRequest) AddGamesToAJackpotPoolTypeRequest(addGamesToAJackpotPoolTypeRequest AddGamesToAJackpotPoolTypeRequest) ApiAddGamesToAJackpotPoolTypeRequest {
	r.addGamesToAJackpotPoolTypeRequest = &addGamesToAJackpotPoolTypeRequest
	return r
}

func (r ApiAddGamesToAJackpotPoolTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddGamesToAJackpotPoolTypeExecute(r)
}

/*
AddGamesToAJackpotPoolType Add games to a jackpot pool type



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddGamesToAJackpotPoolTypeRequest
*/
func (a *EndpointsAPIService) AddGamesToAJackpotPoolType(ctx context.Context) ApiAddGamesToAJackpotPoolTypeRequest {
	return ApiAddGamesToAJackpotPoolTypeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) AddGamesToAJackpotPoolTypeExecute(r ApiAddGamesToAJackpotPoolTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.AddGamesToAJackpotPoolType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/jackpot/games"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addGamesToAJackpotPoolTypeRequest == nil {
		return nil, reportError("addGamesToAJackpotPoolTypeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addGamesToAJackpotPoolTypeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBulkCreateExternalGamesFromJSONArrayRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	bulkCreateExternalGamesFromJSONArrayRequest *BulkCreateExternalGamesFromJSONArrayRequest
}

func (r ApiBulkCreateExternalGamesFromJSONArrayRequest) BulkCreateExternalGamesFromJSONArrayRequest(bulkCreateExternalGamesFromJSONArrayRequest BulkCreateExternalGamesFromJSONArrayRequest) ApiBulkCreateExternalGamesFromJSONArrayRequest {
	r.bulkCreateExternalGamesFromJSONArrayRequest = &bulkCreateExternalGamesFromJSONArrayRequest
	return r
}

func (r ApiBulkCreateExternalGamesFromJSONArrayRequest) Execute() (*http.Response, error) {
	return r.ApiService.BulkCreateExternalGamesFromJSONArrayExecute(r)
}

/*
BulkCreateExternalGamesFromJSONArray Bulk create external games from JSON array



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkCreateExternalGamesFromJSONArrayRequest
*/
func (a *EndpointsAPIService) BulkCreateExternalGamesFromJSONArray(ctx context.Context) ApiBulkCreateExternalGamesFromJSONArrayRequest {
	return ApiBulkCreateExternalGamesFromJSONArrayRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) BulkCreateExternalGamesFromJSONArrayExecute(r ApiBulkCreateExternalGamesFromJSONArrayRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.BulkCreateExternalGamesFromJSONArray")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/external-games/bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkCreateExternalGamesFromJSONArrayRequest == nil {
		return nil, reportError("bulkCreateExternalGamesFromJSONArrayRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkCreateExternalGamesFromJSONArrayRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBulkDeleteExternalGamesByIDsRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	bulkDeleteExternalGamesByIDsRequest *BulkDeleteExternalGamesByIDsRequest
}

func (r ApiBulkDeleteExternalGamesByIDsRequest) BulkDeleteExternalGamesByIDsRequest(bulkDeleteExternalGamesByIDsRequest BulkDeleteExternalGamesByIDsRequest) ApiBulkDeleteExternalGamesByIDsRequest {
	r.bulkDeleteExternalGamesByIDsRequest = &bulkDeleteExternalGamesByIDsRequest
	return r
}

func (r ApiBulkDeleteExternalGamesByIDsRequest) Execute() (*http.Response, error) {
	return r.ApiService.BulkDeleteExternalGamesByIDsExecute(r)
}

/*
BulkDeleteExternalGamesByIDs Bulk delete external games by IDs



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkDeleteExternalGamesByIDsRequest
*/
func (a *EndpointsAPIService) BulkDeleteExternalGamesByIDs(ctx context.Context) ApiBulkDeleteExternalGamesByIDsRequest {
	return ApiBulkDeleteExternalGamesByIDsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) BulkDeleteExternalGamesByIDsExecute(r ApiBulkDeleteExternalGamesByIDsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.BulkDeleteExternalGamesByIDs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/external-games/bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkDeleteExternalGamesByIDsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConfigureJackpotSettingsForTheOperatorRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	configureJackpotSettingsForTheOperatorRequest *ConfigureJackpotSettingsForTheOperatorRequest
}

func (r ApiConfigureJackpotSettingsForTheOperatorRequest) ConfigureJackpotSettingsForTheOperatorRequest(configureJackpotSettingsForTheOperatorRequest ConfigureJackpotSettingsForTheOperatorRequest) ApiConfigureJackpotSettingsForTheOperatorRequest {
	r.configureJackpotSettingsForTheOperatorRequest = &configureJackpotSettingsForTheOperatorRequest
	return r
}

func (r ApiConfigureJackpotSettingsForTheOperatorRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConfigureJackpotSettingsForTheOperatorExecute(r)
}

/*
ConfigureJackpotSettingsForTheOperator Configure jackpot settings for the operator



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConfigureJackpotSettingsForTheOperatorRequest
*/
func (a *EndpointsAPIService) ConfigureJackpotSettingsForTheOperator(ctx context.Context) ApiConfigureJackpotSettingsForTheOperatorRequest {
	return ApiConfigureJackpotSettingsForTheOperatorRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) ConfigureJackpotSettingsForTheOperatorExecute(r ApiConfigureJackpotSettingsForTheOperatorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.ConfigureJackpotSettingsForTheOperator")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/jackpot/configure"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configureJackpotSettingsForTheOperatorRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConfigureLiveModeSettingsForAPoolRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	poolId string
	configureLiveModeSettingsForAPoolRequest *ConfigureLiveModeSettingsForAPoolRequest
}

func (r ApiConfigureLiveModeSettingsForAPoolRequest) ConfigureLiveModeSettingsForAPoolRequest(configureLiveModeSettingsForAPoolRequest ConfigureLiveModeSettingsForAPoolRequest) ApiConfigureLiveModeSettingsForAPoolRequest {
	r.configureLiveModeSettingsForAPoolRequest = &configureLiveModeSettingsForAPoolRequest
	return r
}

func (r ApiConfigureLiveModeSettingsForAPoolRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConfigureLiveModeSettingsForAPoolExecute(r)
}

/*
ConfigureLiveModeSettingsForAPool Configure live mode settings for a pool



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param poolId 
 @return ApiConfigureLiveModeSettingsForAPoolRequest
*/
func (a *EndpointsAPIService) ConfigureLiveModeSettingsForAPool(ctx context.Context, poolId string) ApiConfigureLiveModeSettingsForAPoolRequest {
	return ApiConfigureLiveModeSettingsForAPoolRequest{
		ApiService: a,
		ctx: ctx,
		poolId: poolId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) ConfigureLiveModeSettingsForAPoolExecute(r ApiConfigureLiveModeSettingsForAPoolRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.ConfigureLiveModeSettingsForAPool")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/jackpot/pools/{poolId}/live-mode"
	localVarPath = strings.Replace(localVarPath, "{"+"poolId"+"}", url.PathEscape(parameterValueToString(r.poolId, "poolId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.configureLiveModeSettingsForAPoolRequest == nil {
		return nil, reportError("configureLiveModeSettingsForAPoolRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.configureLiveModeSettingsForAPoolRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateANewPromotionRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	createANewPromotionRequest *CreateANewPromotionRequest
}

func (r ApiCreateANewPromotionRequest) CreateANewPromotionRequest(createANewPromotionRequest CreateANewPromotionRequest) ApiCreateANewPromotionRequest {
	r.createANewPromotionRequest = &createANewPromotionRequest
	return r
}

func (r ApiCreateANewPromotionRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateANewPromotionExecute(r)
}

/*
CreateANewPromotion Create a new promotion



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateANewPromotionRequest
*/
func (a *EndpointsAPIService) CreateANewPromotion(ctx context.Context) ApiCreateANewPromotionRequest {
	return ApiCreateANewPromotionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) CreateANewPromotionExecute(r ApiCreateANewPromotionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.CreateANewPromotion")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/promotions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createANewPromotionRequest == nil {
		return nil, reportError("createANewPromotionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createANewPromotionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateASingleExternalGameRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	createASingleExternalGameRequest *CreateASingleExternalGameRequest
}

func (r ApiCreateASingleExternalGameRequest) CreateASingleExternalGameRequest(createASingleExternalGameRequest CreateASingleExternalGameRequest) ApiCreateASingleExternalGameRequest {
	r.createASingleExternalGameRequest = &createASingleExternalGameRequest
	return r
}

func (r ApiCreateASingleExternalGameRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateASingleExternalGameExecute(r)
}

/*
CreateASingleExternalGame Create a single external game



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateASingleExternalGameRequest
*/
func (a *EndpointsAPIService) CreateASingleExternalGame(ctx context.Context) ApiCreateASingleExternalGameRequest {
	return ApiCreateASingleExternalGameRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) CreateASingleExternalGameExecute(r ApiCreateASingleExternalGameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.CreateASingleExternalGame")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/external-games"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createASingleExternalGameRequest == nil {
		return nil, reportError("createASingleExternalGameRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createASingleExternalGameRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateATargetedPlayerConfigurationRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	createATargetedPlayerConfigurationRequest *CreateATargetedPlayerConfigurationRequest
}

func (r ApiCreateATargetedPlayerConfigurationRequest) CreateATargetedPlayerConfigurationRequest(createATargetedPlayerConfigurationRequest CreateATargetedPlayerConfigurationRequest) ApiCreateATargetedPlayerConfigurationRequest {
	r.createATargetedPlayerConfigurationRequest = &createATargetedPlayerConfigurationRequest
	return r
}

func (r ApiCreateATargetedPlayerConfigurationRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateATargetedPlayerConfigurationExecute(r)
}

/*
CreateATargetedPlayerConfiguration Create a targeted player configuration



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateATargetedPlayerConfigurationRequest
*/
func (a *EndpointsAPIService) CreateATargetedPlayerConfiguration(ctx context.Context) ApiCreateATargetedPlayerConfigurationRequest {
	return ApiCreateATargetedPlayerConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) CreateATargetedPlayerConfigurationExecute(r ApiCreateATargetedPlayerConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.CreateATargetedPlayerConfiguration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/jackpot/targeted-players"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createATargetedPlayerConfigurationRequest == nil {
		return nil, reportError("createATargetedPlayerConfigurationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createATargetedPlayerConfigurationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeactivateATargetedPlayerConfigurationRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	targetedPlayerId string
}

func (r ApiDeactivateATargetedPlayerConfigurationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeactivateATargetedPlayerConfigurationExecute(r)
}

/*
DeactivateATargetedPlayerConfiguration Deactivate a targeted player configuration



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param targetedPlayerId 
 @return ApiDeactivateATargetedPlayerConfigurationRequest
*/
func (a *EndpointsAPIService) DeactivateATargetedPlayerConfiguration(ctx context.Context, targetedPlayerId string) ApiDeactivateATargetedPlayerConfigurationRequest {
	return ApiDeactivateATargetedPlayerConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		targetedPlayerId: targetedPlayerId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) DeactivateATargetedPlayerConfigurationExecute(r ApiDeactivateATargetedPlayerConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.DeactivateATargetedPlayerConfiguration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/jackpot/targeted-players/{targetedPlayerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"targetedPlayerId"+"}", url.PathEscape(parameterValueToString(r.targetedPlayerId, "targetedPlayerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteAPromotionRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	id string
}

func (r ApiDeleteAPromotionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAPromotionExecute(r)
}

/*
DeleteAPromotion Delete a promotion



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the promotion.
 @return ApiDeleteAPromotionRequest
*/
func (a *EndpointsAPIService) DeleteAPromotion(ctx context.Context, id string) ApiDeleteAPromotionRequest {
	return ApiDeleteAPromotionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) DeleteAPromotionExecute(r ApiDeleteAPromotionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.DeleteAPromotion")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/promotions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteAnExternalGameRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	id string
}

func (r ApiDeleteAnExternalGameRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAnExternalGameExecute(r)
}

/*
DeleteAnExternalGame Delete an external game



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the external game.
 @return ApiDeleteAnExternalGameRequest
*/
func (a *EndpointsAPIService) DeleteAnExternalGame(ctx context.Context, id string) ApiDeleteAnExternalGameRequest {
	return ApiDeleteAnExternalGameRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) DeleteAnExternalGameExecute(r ApiDeleteAnExternalGameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.DeleteAnExternalGame")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/external-games/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetASingleExternalGameRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	id string
}

func (r ApiGetASingleExternalGameRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetASingleExternalGameExecute(r)
}

/*
GetASingleExternalGame Get a single external game



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the external game.
 @return ApiGetASingleExternalGameRequest
*/
func (a *EndpointsAPIService) GetASingleExternalGame(ctx context.Context, id string) ApiGetASingleExternalGameRequest {
	return ApiGetASingleExternalGameRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) GetASingleExternalGameExecute(r ApiGetASingleExternalGameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.GetASingleExternalGame")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/external-games/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetApiV1Producers401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetASpecificPromotionRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	id string
}

func (r ApiGetASpecificPromotionRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetASpecificPromotionExecute(r)
}

/*
GetASpecificPromotion Get a specific promotion



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the promotion.
 @return ApiGetASpecificPromotionRequest
*/
func (a *EndpointsAPIService) GetASpecificPromotion(ctx context.Context, id string) ApiGetASpecificPromotionRequest {
	return ApiGetASpecificPromotionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) GetASpecificPromotionExecute(r ApiGetASpecificPromotionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.GetASpecificPromotion")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/promotions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetApiV1Producers401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetApiV1ProducersRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
}

func (r ApiGetApiV1ProducersRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetApiV1ProducersExecute(r)
}

/*
GetApiV1Producers 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetApiV1ProducersRequest
*/
func (a *EndpointsAPIService) GetApiV1Producers(ctx context.Context) ApiGetApiV1ProducersRequest {
	return ApiGetApiV1ProducersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) GetApiV1ProducersExecute(r ApiGetApiV1ProducersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.GetApiV1Producers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/producers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetApiV1Producers401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetApiV1ProducersIdRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	id string
}

func (r ApiGetApiV1ProducersIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetApiV1ProducersIdExecute(r)
}

/*
GetApiV1ProducersId 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the producer.
 @return ApiGetApiV1ProducersIdRequest
*/
func (a *EndpointsAPIService) GetApiV1ProducersId(ctx context.Context, id string) ApiGetApiV1ProducersIdRequest {
	return ApiGetApiV1ProducersIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) GetApiV1ProducersIdExecute(r ApiGetApiV1ProducersIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.GetApiV1ProducersId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/producers/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetApiV1Producers401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetApiV1TransactionExportsExportIdDownloadRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	exportId int32
}

func (r ApiGetApiV1TransactionExportsExportIdDownloadRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetApiV1TransactionExportsExportIdDownloadExecute(r)
}

/*
GetApiV1TransactionExportsExportIdDownload 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param exportId The ID of the export.
 @return ApiGetApiV1TransactionExportsExportIdDownloadRequest
*/
func (a *EndpointsAPIService) GetApiV1TransactionExportsExportIdDownload(ctx context.Context, exportId int32) ApiGetApiV1TransactionExportsExportIdDownloadRequest {
	return ApiGetApiV1TransactionExportsExportIdDownloadRequest{
		ApiService: a,
		ctx: ctx,
		exportId: exportId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) GetApiV1TransactionExportsExportIdDownloadExecute(r ApiGetApiV1TransactionExportsExportIdDownloadRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.GetApiV1TransactionExportsExportIdDownload")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/transaction-exports/{export_id}/download"
	localVarPath = strings.Replace(localVarPath, "{"+"export_id"+"}", url.PathEscape(parameterValueToString(r.exportId, "exportId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetApiV1TransactionExportsExportIdDownload500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCurrentConfigurationWithGamesRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
}

func (r ApiGetCurrentConfigurationWithGamesRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetCurrentConfigurationWithGamesExecute(r)
}

/*
GetCurrentConfigurationWithGames Get current configuration with games



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCurrentConfigurationWithGamesRequest
*/
func (a *EndpointsAPIService) GetCurrentConfigurationWithGames(ctx context.Context) ApiGetCurrentConfigurationWithGamesRequest {
	return ApiGetCurrentConfigurationWithGamesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) GetCurrentConfigurationWithGamesExecute(r ApiGetCurrentConfigurationWithGamesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.GetCurrentConfigurationWithGames")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/jackpot/configuration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetApiV1Producers401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetGamesForAPoolTypeOrAllPoolTypesRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	getGamesForAPoolTypeOrAllPoolTypesRequest *GetGamesForAPoolTypeOrAllPoolTypesRequest
}

func (r ApiGetGamesForAPoolTypeOrAllPoolTypesRequest) GetGamesForAPoolTypeOrAllPoolTypesRequest(getGamesForAPoolTypeOrAllPoolTypesRequest GetGamesForAPoolTypeOrAllPoolTypesRequest) ApiGetGamesForAPoolTypeOrAllPoolTypesRequest {
	r.getGamesForAPoolTypeOrAllPoolTypesRequest = &getGamesForAPoolTypeOrAllPoolTypesRequest
	return r
}

func (r ApiGetGamesForAPoolTypeOrAllPoolTypesRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetGamesForAPoolTypeOrAllPoolTypesExecute(r)
}

/*
GetGamesForAPoolTypeOrAllPoolTypes Get games for a pool type or all pool types



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGamesForAPoolTypeOrAllPoolTypesRequest
*/
func (a *EndpointsAPIService) GetGamesForAPoolTypeOrAllPoolTypes(ctx context.Context) ApiGetGamesForAPoolTypeOrAllPoolTypesRequest {
	return ApiGetGamesForAPoolTypeOrAllPoolTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) GetGamesForAPoolTypeOrAllPoolTypesExecute(r ApiGetGamesForAPoolTypeOrAllPoolTypesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.GetGamesForAPoolTypeOrAllPoolTypes")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/jackpot/games"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getGamesForAPoolTypeOrAllPoolTypesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetApiV1Producers401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetLeaderboardForAPromotionRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	id string
}

func (r ApiGetLeaderboardForAPromotionRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetLeaderboardForAPromotionExecute(r)
}

/*
GetLeaderboardForAPromotion Get leaderboard for a promotion



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the promotion.
 @return ApiGetLeaderboardForAPromotionRequest
*/
func (a *EndpointsAPIService) GetLeaderboardForAPromotion(ctx context.Context, id string) ApiGetLeaderboardForAPromotionRequest {
	return ApiGetLeaderboardForAPromotionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) GetLeaderboardForAPromotionExecute(r ApiGetLeaderboardForAPromotionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.GetLeaderboardForAPromotion")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/promotions/{id}/leaderboard"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetApiV1Producers401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPlayerContributionHistoryRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	getPlayerContributionHistoryRequest *GetPlayerContributionHistoryRequest
}

func (r ApiGetPlayerContributionHistoryRequest) GetPlayerContributionHistoryRequest(getPlayerContributionHistoryRequest GetPlayerContributionHistoryRequest) ApiGetPlayerContributionHistoryRequest {
	r.getPlayerContributionHistoryRequest = &getPlayerContributionHistoryRequest
	return r
}

func (r ApiGetPlayerContributionHistoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetPlayerContributionHistoryExecute(r)
}

/*
GetPlayerContributionHistory Get player contribution history



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPlayerContributionHistoryRequest
*/
func (a *EndpointsAPIService) GetPlayerContributionHistory(ctx context.Context) ApiGetPlayerContributionHistoryRequest {
	return ApiGetPlayerContributionHistoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) GetPlayerContributionHistoryExecute(r ApiGetPlayerContributionHistoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.GetPlayerContributionHistory")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/jackpot/contributions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getPlayerContributionHistoryRequest == nil {
		return nil, reportError("getPlayerContributionHistoryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getPlayerContributionHistoryRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetApiV1Producers401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPoolDetailsRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	poolId string
}

func (r ApiGetPoolDetailsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetPoolDetailsExecute(r)
}

/*
GetPoolDetails Get pool details



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param poolId 
 @return ApiGetPoolDetailsRequest
*/
func (a *EndpointsAPIService) GetPoolDetails(ctx context.Context, poolId string) ApiGetPoolDetailsRequest {
	return ApiGetPoolDetailsRequest{
		ApiService: a,
		ctx: ctx,
		poolId: poolId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) GetPoolDetailsExecute(r ApiGetPoolDetailsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.GetPoolDetails")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/jackpot/pools/{poolId}"
	localVarPath = strings.Replace(localVarPath, "{"+"poolId"+"}", url.PathEscape(parameterValueToString(r.poolId, "poolId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetApiV1Producers401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPoolWinnersRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	poolId string
}

func (r ApiGetPoolWinnersRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetPoolWinnersExecute(r)
}

/*
GetPoolWinners Get pool winners



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param poolId 
 @return ApiGetPoolWinnersRequest
*/
func (a *EndpointsAPIService) GetPoolWinners(ctx context.Context, poolId string) ApiGetPoolWinnersRequest {
	return ApiGetPoolWinnersRequest{
		ApiService: a,
		ctx: ctx,
		poolId: poolId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) GetPoolWinnersExecute(r ApiGetPoolWinnersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.GetPoolWinners")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/jackpot/pools/{poolId}/winners"
	localVarPath = strings.Replace(localVarPath, "{"+"poolId"+"}", url.PathEscape(parameterValueToString(r.poolId, "poolId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetApiV1Producers401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetTargetedPlayerDetailsRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	targetedPlayerId string
}

func (r ApiGetTargetedPlayerDetailsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetTargetedPlayerDetailsExecute(r)
}

/*
GetTargetedPlayerDetails Get targeted player details



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param targetedPlayerId 
 @return ApiGetTargetedPlayerDetailsRequest
*/
func (a *EndpointsAPIService) GetTargetedPlayerDetails(ctx context.Context, targetedPlayerId string) ApiGetTargetedPlayerDetailsRequest {
	return ApiGetTargetedPlayerDetailsRequest{
		ApiService: a,
		ctx: ctx,
		targetedPlayerId: targetedPlayerId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) GetTargetedPlayerDetailsExecute(r ApiGetTargetedPlayerDetailsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.GetTargetedPlayerDetails")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/jackpot/targeted-players/{targetedPlayerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"targetedPlayerId"+"}", url.PathEscape(parameterValueToString(r.targetedPlayerId, "targetedPlayerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetApiV1Producers401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetUniqueProducerNamesForFilteringRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
}

func (r ApiGetUniqueProducerNamesForFilteringRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetUniqueProducerNamesForFilteringExecute(r)
}

/*
GetUniqueProducerNamesForFiltering Get unique producer names for filtering



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUniqueProducerNamesForFilteringRequest
*/
func (a *EndpointsAPIService) GetUniqueProducerNamesForFiltering(ctx context.Context) ApiGetUniqueProducerNamesForFilteringRequest {
	return ApiGetUniqueProducerNamesForFilteringRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) GetUniqueProducerNamesForFilteringExecute(r ApiGetUniqueProducerNamesForFilteringRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.GetUniqueProducerNamesForFiltering")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/external-games/producers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetApiV1Producers401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetWinnersForAPromotionRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	id string
}

func (r ApiGetWinnersForAPromotionRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetWinnersForAPromotionExecute(r)
}

/*
GetWinnersForAPromotion Get winners for a promotion



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the promotion.
 @return ApiGetWinnersForAPromotionRequest
*/
func (a *EndpointsAPIService) GetWinnersForAPromotion(ctx context.Context, id string) ApiGetWinnersForAPromotionRequest {
	return ApiGetWinnersForAPromotionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) GetWinnersForAPromotionExecute(r ApiGetWinnersForAPromotionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.GetWinnersForAPromotion")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/promotions/{id}/winners"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetApiV1Producers401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiImportExternalGamesFromCSVFileRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	file *os.File
}

// Must be a file. Must not be greater than 10240 kilobytes.
func (r ApiImportExternalGamesFromCSVFileRequest) File(file *os.File) ApiImportExternalGamesFromCSVFileRequest {
	r.file = file
	return r
}

func (r ApiImportExternalGamesFromCSVFileRequest) Execute() (*http.Response, error) {
	return r.ApiService.ImportExternalGamesFromCSVFileExecute(r)
}

/*
ImportExternalGamesFromCSVFile Import external games from CSV file



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiImportExternalGamesFromCSVFileRequest
*/
func (a *EndpointsAPIService) ImportExternalGamesFromCSVFile(ctx context.Context) ApiImportExternalGamesFromCSVFileRequest {
	return ApiImportExternalGamesFromCSVFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) ImportExternalGamesFromCSVFileExecute(r ApiImportExternalGamesFromCSVFileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.ImportExternalGamesFromCSVFile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/external-games/import/csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.file == nil {
		return nil, reportError("file is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiImportExternalGamesFromJSONPasteRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	importExternalGamesFromJSONPasteRequest *ImportExternalGamesFromJSONPasteRequest
}

func (r ApiImportExternalGamesFromJSONPasteRequest) ImportExternalGamesFromJSONPasteRequest(importExternalGamesFromJSONPasteRequest ImportExternalGamesFromJSONPasteRequest) ApiImportExternalGamesFromJSONPasteRequest {
	r.importExternalGamesFromJSONPasteRequest = &importExternalGamesFromJSONPasteRequest
	return r
}

func (r ApiImportExternalGamesFromJSONPasteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ImportExternalGamesFromJSONPasteExecute(r)
}

/*
ImportExternalGamesFromJSONPaste Import external games from JSON paste



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiImportExternalGamesFromJSONPasteRequest
*/
func (a *EndpointsAPIService) ImportExternalGamesFromJSONPaste(ctx context.Context) ApiImportExternalGamesFromJSONPasteRequest {
	return ApiImportExternalGamesFromJSONPasteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) ImportExternalGamesFromJSONPasteExecute(r ApiImportExternalGamesFromJSONPasteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.ImportExternalGamesFromJSONPaste")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/external-games/import/json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.importExternalGamesFromJSONPasteRequest == nil {
		return nil, reportError("importExternalGamesFromJSONPasteRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.importExternalGamesFromJSONPasteRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListExternalGamesForOperatorRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	listExternalGamesForOperatorRequest *ListExternalGamesForOperatorRequest
}

func (r ApiListExternalGamesForOperatorRequest) ListExternalGamesForOperatorRequest(listExternalGamesForOperatorRequest ListExternalGamesForOperatorRequest) ApiListExternalGamesForOperatorRequest {
	r.listExternalGamesForOperatorRequest = &listExternalGamesForOperatorRequest
	return r
}

func (r ApiListExternalGamesForOperatorRequest) Execute() (*http.Response, error) {
	return r.ApiService.ListExternalGamesForOperatorExecute(r)
}

/*
ListExternalGamesForOperator List external games for operator



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListExternalGamesForOperatorRequest
*/
func (a *EndpointsAPIService) ListExternalGamesForOperator(ctx context.Context) ApiListExternalGamesForOperatorRequest {
	return ApiListExternalGamesForOperatorRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) ListExternalGamesForOperatorExecute(r ApiListExternalGamesForOperatorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.ListExternalGamesForOperator")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/external-games"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.listExternalGamesForOperatorRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetApiV1Producers401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListOperatorsJackpotPoolsRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	listOperatorsJackpotPoolsRequest *ListOperatorsJackpotPoolsRequest
}

func (r ApiListOperatorsJackpotPoolsRequest) ListOperatorsJackpotPoolsRequest(listOperatorsJackpotPoolsRequest ListOperatorsJackpotPoolsRequest) ApiListOperatorsJackpotPoolsRequest {
	r.listOperatorsJackpotPoolsRequest = &listOperatorsJackpotPoolsRequest
	return r
}

func (r ApiListOperatorsJackpotPoolsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ListOperatorsJackpotPoolsExecute(r)
}

/*
ListOperatorsJackpotPools List operator's jackpot pools



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListOperatorsJackpotPoolsRequest
*/
func (a *EndpointsAPIService) ListOperatorsJackpotPools(ctx context.Context) ApiListOperatorsJackpotPoolsRequest {
	return ApiListOperatorsJackpotPoolsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) ListOperatorsJackpotPoolsExecute(r ApiListOperatorsJackpotPoolsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.ListOperatorsJackpotPools")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/jackpot/pools"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.listOperatorsJackpotPoolsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetApiV1Producers401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListPromotionsForTheOperatorRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
}

func (r ApiListPromotionsForTheOperatorRequest) Execute() (*http.Response, error) {
	return r.ApiService.ListPromotionsForTheOperatorExecute(r)
}

/*
ListPromotionsForTheOperator List promotions for the operator



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListPromotionsForTheOperatorRequest
*/
func (a *EndpointsAPIService) ListPromotionsForTheOperator(ctx context.Context) ApiListPromotionsForTheOperatorRequest {
	return ApiListPromotionsForTheOperatorRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) ListPromotionsForTheOperatorExecute(r ApiListPromotionsForTheOperatorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.ListPromotionsForTheOperator")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/promotions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetApiV1Producers401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListTargetedPlayersForOperatorRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	listTargetedPlayersForOperatorRequest *ListTargetedPlayersForOperatorRequest
}

func (r ApiListTargetedPlayersForOperatorRequest) ListTargetedPlayersForOperatorRequest(listTargetedPlayersForOperatorRequest ListTargetedPlayersForOperatorRequest) ApiListTargetedPlayersForOperatorRequest {
	r.listTargetedPlayersForOperatorRequest = &listTargetedPlayersForOperatorRequest
	return r
}

func (r ApiListTargetedPlayersForOperatorRequest) Execute() (*http.Response, error) {
	return r.ApiService.ListTargetedPlayersForOperatorExecute(r)
}

/*
ListTargetedPlayersForOperator List targeted players for operator



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListTargetedPlayersForOperatorRequest
*/
func (a *EndpointsAPIService) ListTargetedPlayersForOperator(ctx context.Context) ApiListTargetedPlayersForOperatorRequest {
	return ApiListTargetedPlayersForOperatorRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) ListTargetedPlayersForOperatorExecute(r ApiListTargetedPlayersForOperatorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.ListTargetedPlayersForOperator")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/jackpot/targeted-players"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.listTargetedPlayersForOperatorRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetApiV1Producers401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiManageGamesForAPromotionRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	id string
	manageGamesForAPromotionRequest *ManageGamesForAPromotionRequest
}

func (r ApiManageGamesForAPromotionRequest) ManageGamesForAPromotionRequest(manageGamesForAPromotionRequest ManageGamesForAPromotionRequest) ApiManageGamesForAPromotionRequest {
	r.manageGamesForAPromotionRequest = &manageGamesForAPromotionRequest
	return r
}

func (r ApiManageGamesForAPromotionRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManageGamesForAPromotionExecute(r)
}

/*
ManageGamesForAPromotion Manage games for a promotion



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the promotion.
 @return ApiManageGamesForAPromotionRequest
*/
func (a *EndpointsAPIService) ManageGamesForAPromotion(ctx context.Context, id string) ApiManageGamesForAPromotionRequest {
	return ApiManageGamesForAPromotionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) ManageGamesForAPromotionExecute(r ApiManageGamesForAPromotionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.ManageGamesForAPromotion")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/promotions/{id}/games"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.manageGamesForAPromotionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiManuallyDistributePrizesForAPeriodRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	id string
	periodId string
}

func (r ApiManuallyDistributePrizesForAPeriodRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManuallyDistributePrizesForAPeriodExecute(r)
}

/*
ManuallyDistributePrizesForAPeriod Manually distribute prizes for a period



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the promotion.
 @param periodId 
 @return ApiManuallyDistributePrizesForAPeriodRequest
*/
func (a *EndpointsAPIService) ManuallyDistributePrizesForAPeriod(ctx context.Context, id string, periodId string) ApiManuallyDistributePrizesForAPeriodRequest {
	return ApiManuallyDistributePrizesForAPeriodRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		periodId: periodId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) ManuallyDistributePrizesForAPeriodExecute(r ApiManuallyDistributePrizesForAPeriodRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.ManuallyDistributePrizesForAPeriod")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/promotions/{id}/periods/{periodId}/distribute"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"periodId"+"}", url.PathEscape(parameterValueToString(r.periodId, "periodId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiManuallyTriggerPoolReleaseRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	poolId string
}

func (r ApiManuallyTriggerPoolReleaseRequest) Execute() (*http.Response, error) {
	return r.ApiService.ManuallyTriggerPoolReleaseExecute(r)
}

/*
ManuallyTriggerPoolRelease Manually trigger pool release



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param poolId 
 @return ApiManuallyTriggerPoolReleaseRequest
*/
func (a *EndpointsAPIService) ManuallyTriggerPoolRelease(ctx context.Context, poolId string) ApiManuallyTriggerPoolReleaseRequest {
	return ApiManuallyTriggerPoolReleaseRequest{
		ApiService: a,
		ctx: ctx,
		poolId: poolId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) ManuallyTriggerPoolReleaseExecute(r ApiManuallyTriggerPoolReleaseRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.ManuallyTriggerPoolRelease")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/jackpot/pools/{poolId}/release"
	localVarPath = strings.Replace(localVarPath, "{"+"poolId"+"}", url.PathEscape(parameterValueToString(r.poolId, "poolId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOptInOperatorToAPlatformnetworkPromotionRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	id string
}

func (r ApiOptInOperatorToAPlatformnetworkPromotionRequest) Execute() (*http.Response, error) {
	return r.ApiService.OptInOperatorToAPlatformnetworkPromotionExecute(r)
}

/*
OptInOperatorToAPlatformnetworkPromotion Opt-in operator to a platform/network promotion



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the promotion.
 @return ApiOptInOperatorToAPlatformnetworkPromotionRequest
*/
func (a *EndpointsAPIService) OptInOperatorToAPlatformnetworkPromotion(ctx context.Context, id string) ApiOptInOperatorToAPlatformnetworkPromotionRequest {
	return ApiOptInOperatorToAPlatformnetworkPromotionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) OptInOperatorToAPlatformnetworkPromotionExecute(r ApiOptInOperatorToAPlatformnetworkPromotionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.OptInOperatorToAPlatformnetworkPromotion")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/promotions/{id}/opt-in"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiOptOutOperatorFromAPlatformnetworkPromotionRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	id string
}

func (r ApiOptOutOperatorFromAPlatformnetworkPromotionRequest) Execute() (*http.Response, error) {
	return r.ApiService.OptOutOperatorFromAPlatformnetworkPromotionExecute(r)
}

/*
OptOutOperatorFromAPlatformnetworkPromotion Opt-out operator from a platform/network promotion



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the promotion.
 @return ApiOptOutOperatorFromAPlatformnetworkPromotionRequest
*/
func (a *EndpointsAPIService) OptOutOperatorFromAPlatformnetworkPromotion(ctx context.Context, id string) ApiOptOutOperatorFromAPlatformnetworkPromotionRequest {
	return ApiOptOutOperatorFromAPlatformnetworkPromotionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) OptOutOperatorFromAPlatformnetworkPromotionExecute(r ApiOptOutOperatorFromAPlatformnetworkPromotionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.OptOutOperatorFromAPlatformnetworkPromotion")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/promotions/{id}/opt-out"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostApiV1GameTransactionsExportRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	postApiV1GameTransactionsExportRequest *PostApiV1GameTransactionsExportRequest
}

func (r ApiPostApiV1GameTransactionsExportRequest) PostApiV1GameTransactionsExportRequest(postApiV1GameTransactionsExportRequest PostApiV1GameTransactionsExportRequest) ApiPostApiV1GameTransactionsExportRequest {
	r.postApiV1GameTransactionsExportRequest = &postApiV1GameTransactionsExportRequest
	return r
}

func (r ApiPostApiV1GameTransactionsExportRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostApiV1GameTransactionsExportExecute(r)
}

/*
PostApiV1GameTransactionsExport 



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostApiV1GameTransactionsExportRequest
*/
func (a *EndpointsAPIService) PostApiV1GameTransactionsExport(ctx context.Context) ApiPostApiV1GameTransactionsExportRequest {
	return ApiPostApiV1GameTransactionsExportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) PostApiV1GameTransactionsExportExecute(r ApiPostApiV1GameTransactionsExportRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.PostApiV1GameTransactionsExport")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/game-transactions/export"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postApiV1GameTransactionsExportRequest == nil {
		return nil, reportError("postApiV1GameTransactionsExportRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postApiV1GameTransactionsExportRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveGamesFromAJackpotPoolTypeRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	removeGamesFromAJackpotPoolTypeRequest *RemoveGamesFromAJackpotPoolTypeRequest
}

func (r ApiRemoveGamesFromAJackpotPoolTypeRequest) RemoveGamesFromAJackpotPoolTypeRequest(removeGamesFromAJackpotPoolTypeRequest RemoveGamesFromAJackpotPoolTypeRequest) ApiRemoveGamesFromAJackpotPoolTypeRequest {
	r.removeGamesFromAJackpotPoolTypeRequest = &removeGamesFromAJackpotPoolTypeRequest
	return r
}

func (r ApiRemoveGamesFromAJackpotPoolTypeRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveGamesFromAJackpotPoolTypeExecute(r)
}

/*
RemoveGamesFromAJackpotPoolType Remove games from a jackpot pool type



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRemoveGamesFromAJackpotPoolTypeRequest
*/
func (a *EndpointsAPIService) RemoveGamesFromAJackpotPoolType(ctx context.Context) ApiRemoveGamesFromAJackpotPoolTypeRequest {
	return ApiRemoveGamesFromAJackpotPoolTypeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) RemoveGamesFromAJackpotPoolTypeExecute(r ApiRemoveGamesFromAJackpotPoolTypeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.RemoveGamesFromAJackpotPoolType")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/jackpot/games"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.removeGamesFromAJackpotPoolTypeRequest == nil {
		return nil, reportError("removeGamesFromAJackpotPoolTypeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.removeGamesFromAJackpotPoolTypeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetGrandPrizeExpirationDateRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	poolId string
	setGrandPrizeExpirationDateRequest *SetGrandPrizeExpirationDateRequest
}

func (r ApiSetGrandPrizeExpirationDateRequest) SetGrandPrizeExpirationDateRequest(setGrandPrizeExpirationDateRequest SetGrandPrizeExpirationDateRequest) ApiSetGrandPrizeExpirationDateRequest {
	r.setGrandPrizeExpirationDateRequest = &setGrandPrizeExpirationDateRequest
	return r
}

func (r ApiSetGrandPrizeExpirationDateRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetGrandPrizeExpirationDateExecute(r)
}

/*
SetGrandPrizeExpirationDate Set grand prize expiration date



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param poolId 
 @return ApiSetGrandPrizeExpirationDateRequest
*/
func (a *EndpointsAPIService) SetGrandPrizeExpirationDate(ctx context.Context, poolId string) ApiSetGrandPrizeExpirationDateRequest {
	return ApiSetGrandPrizeExpirationDateRequest{
		ApiService: a,
		ctx: ctx,
		poolId: poolId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) SetGrandPrizeExpirationDateExecute(r ApiSetGrandPrizeExpirationDateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.SetGrandPrizeExpirationDate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/jackpot/pools/{poolId}/expiration"
	localVarPath = strings.Replace(localVarPath, "{"+"poolId"+"}", url.PathEscape(parameterValueToString(r.poolId, "poolId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.setGrandPrizeExpirationDateRequest == nil {
		return nil, reportError("setGrandPrizeExpirationDateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setGrandPrizeExpirationDateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAPromotionRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	id string
	updateAPromotionRequest *UpdateAPromotionRequest
}

func (r ApiUpdateAPromotionRequest) UpdateAPromotionRequest(updateAPromotionRequest UpdateAPromotionRequest) ApiUpdateAPromotionRequest {
	r.updateAPromotionRequest = &updateAPromotionRequest
	return r
}

func (r ApiUpdateAPromotionRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAPromotionExecute(r)
}

/*
UpdateAPromotion Update a promotion



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the promotion.
 @return ApiUpdateAPromotionRequest
*/
func (a *EndpointsAPIService) UpdateAPromotion(ctx context.Context, id string) ApiUpdateAPromotionRequest {
	return ApiUpdateAPromotionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) UpdateAPromotionExecute(r ApiUpdateAPromotionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.UpdateAPromotion")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/promotions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateAPromotionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAnExternalGameRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	id string
	updateAnExternalGameRequest *UpdateAnExternalGameRequest
}

func (r ApiUpdateAnExternalGameRequest) UpdateAnExternalGameRequest(updateAnExternalGameRequest UpdateAnExternalGameRequest) ApiUpdateAnExternalGameRequest {
	r.updateAnExternalGameRequest = &updateAnExternalGameRequest
	return r
}

func (r ApiUpdateAnExternalGameRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAnExternalGameExecute(r)
}

/*
UpdateAnExternalGame Update an external game



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the external game.
 @return ApiUpdateAnExternalGameRequest
*/
func (a *EndpointsAPIService) UpdateAnExternalGame(ctx context.Context, id string) ApiUpdateAnExternalGameRequest {
	return ApiUpdateAnExternalGameRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) UpdateAnExternalGameExecute(r ApiUpdateAnExternalGameRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.UpdateAnExternalGame")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/external-games/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateAnExternalGameRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
